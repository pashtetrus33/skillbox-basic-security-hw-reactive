# Практическая работа 8.10

### Приложение «Трекер задач» – Защита с помощью Spring Security

#### Что нужно сделать

Защитите приложение «Трекер задач» с помощью Spring Security.

Добавьте для сущности User поля password и roles. В приложении должны быть следующие роли: ROLE_USER, ROLE_MANAGER.  
Проведите для контроллера, отвечающего за работу с пользователями, доработку:
- получение (как списком, так и по ID), обновление и удаление профилей пользователей должны быть доступны только тем клиентам, которые имеют одну из следующих ролей: ROLE_USER, ROLE_MANAGER.

Проведите для контроллера, отвечающего за работу с задачами, доработки:
- получение списка задач, получение задачи по ID, добавление наблюдателя доступны пользователю с одной из следующих ролей: ROLE_USER, ROLE_MANAGER;
- создание, обновление и удаление задачи доступны пользователю с ролью ROLE_MANAGER.

Все данные о текущем пользователе, передаваемые в контроллер, должны быть получены из UserDetails.

#### Рекомендация

При защите приложения «Трекер задач» можете хранить данные о ролях в MongoDB в следующем стиле:

```java
@Field("roles")
private Set<RoleType> roles = new HashSet<>();
```
Здесь RoleType — это перечисление ролей.


# Практическая работа 7.6

## Цель практической работы

Закрепить знания, полученные по следующим темам:
- Написание контроллеров с использованием Mono и Flux.
- Работа с MongoDB в реактивной парадигме.

## Задание

Реализуйте приложение «Трекер задач», которое будет работать с двумя сущностями: **User** и **Task**.

### 1. Сущность User

**Поля:**
- `String id`
- `String username`
- `String email`

### 2. Сущность Task

**Поля:**
- `String id`
- `String name`
- `String description`
- `Instant createdAt`
- `Instant updatedAt`
- `TaskStatus status`
- `String authorId`
- `String assigneeId`
- `Set<String> observerIds`

**Поля, не попадающие в базу данных:**
- `User author`
- `User assignee`
- `Set<User> observers`

**Enum TaskStatus:**
- `TODO`
- `IN_PROGRESS`
- `DONE`

### 3. Маппинг сущностей

Реализовать маппинг сущностей через **MapStruct**.

### 4. Контроллеры

Все контроллеры должны возвращать **Mono** или **Flux**.

### 5. API для сущности User

Создать API, которое предоставляет возможность:
- Найти всех пользователей
- Найти пользователя по ID
- Создать пользователя
- Обновить информацию о пользователе
- Удалить пользователя по ID

### 6. API для сущности Task

Создать API, которое предоставляет возможность:
- Найти все задачи (в ответе также должны находиться вложенные сущности, которые описывают автора задачи и исполнителя, а также содержат список наблюдающих за задачей)
- Найти конкретную задачу по ID (в ответе также должны находиться вложенные сущности, которые описывают автора задачи и исполнителя, а также содержат список наблюдающих за задачей)
- Создать задачу
- Обновить задачу
- Добавить наблюдателя в задачу
- Удалить задачу по ID

## Советы и рекомендации

- В реактивной парадигме вы не можете использовать такие аннотации, как DBRef или DocumentRefrence, для установления связей между сущностями. Вместо этого используйте метод `Mono.zip`, который поможет объединить несколько запросов к базе данных и использовать данные из запроса для установления нужной дочерней сущности.
- Метод `zip` не работает с пустыми значениями Mono и (или) Flux. Убедитесь, что в методе `zip` вы используете значения, которые не являются пустыми (иначе метод не будет выполняться).
- Вы можете использовать аннотацию `@ReadOnlyProperty` над полями сущности, которые не должны попадать в базу данных.
